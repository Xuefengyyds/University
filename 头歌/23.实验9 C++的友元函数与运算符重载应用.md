# 实验9 C++的友元函数与运算符重载应用

## 第1关：求平面直角坐标系中两点间的距离

```cpp
#include<iostream>
#include<cmath>
using namespace std;

class Points{
public:
	Points(double xx=0.0,double yy=0.0);	// 用参数初始化点的坐标
	double GetX()const;	// 返回横坐标
	double GetY()const;	// 返回纵坐标
	friend void print(Points*);	// 输出点的坐标
	friend double distance(Points,Points); // 求两点间的距离
private:
	double x,y;		// 点的坐标
};
Points::Points(double xx,double yy):x(xx),y(yy)
{	}
double Points::GetX( )const
{
	return x;
}
double Points::GetY()const
{
	return y;
}

//ERROR**********found**********
 void print(Points*p)
{
	//ERROR**********found**********
	cout<<"点：("<<p->x<<','<<p->y<<")\n";
    //另一种写法
    //cout<<"点：("<<(*p).x<<','<<(*p).y<<")\n";

}

//ERROR**********found**********
double distance(Points p1,Points p2)
{
	double dx,dy;
	dx=p1.x-p2.x;
	dy=p1.y-p2.y;
	return sqrt(dx*dx+dy*dy);
}

int main()
{
	Points pa,pb(1.0,2.0);
	print(&pa);
	print(&pb);
	//ERROR**********found**********
	cout<<"距离："<<distance(pa,pb)<<endl;
	system("pause");
	return 0;
}
```

## 第2关：复数的加法和乘法运算

```cpp
#include<iostream>
using namespace std;

class Complexs{
public:
	Complexs(double r=0,double i=0):real(r),imag(i){ }
	void print()const;									// 按指定格式输出结果
	//**********found**********
	 Complexs operator+(Complexs&);						// 加法运算
	//**********found**********
	friend Complexs operator*(Complexs&,Complexs&);	// 乘法运算
private:
	double real,imag;									// 复数的实部和虚部
};
void Complexs::print()const
{
	cout<<real;
	if(imag<0)cout<<imag<<'i'<<endl;
	else if(imag>0) cout<<'+'<<imag<<'i'<<endl ;
}
Complexs Complexs::operator+(Complexs & c)
{
	Complexs t;
	t.real=real+c.real;
	t.imag=imag+c.imag;
	//**********found**********
	return t;
}
//**********found**********
 Complexs operator*(Complexs& c1,Complexs& c2)	
{
	Complexs c;
	c.real=c1.real*c2.real-c1.imag*c2.imag;
	//**********found**********
	c.imag=c1.imag*c2.real+c1.real*c2.imag; ;
	return c;
}

int main()
{
	Complexs z1(2.0,3.0),z2(1.0,-4.0),z;
	cout<<"z1：";
	z1.print();
	cout<<"z2：";
	z2.print();
	z=z1+z2;
	cout<<"z1+z2：";
	z.print();
	z=z1*z2;
	cout<<"z1*z2：";
	z.print();
	system("pause");
	return 0;
}
```

## 第3关：时间的运算

```cpp
#include"time.h"

int main()
{
	int h=200,s=5;
	Times t(13,14,58),t1(2,45,18),t2,t3,t4;
	cout<<"现在时间是：";
	cout<<t<<endl;
	t2=h+t;
	cout<<h<<"小时之后是：";
	cout<<t2<<endl;
	t3=t+s;
	cout<<s<<"秒之后是：";
	cout<<t3<<endl;
	t4=t+t1;
	cout<<t1<<"之后是："<<t4<<endl;
	system("pause");
	return 0;
}
```

```cpp
#include"time.h"
//#pragma warning(disable:4996)

Times::Times(int h,int m,int s):hour(h),minute(m),second(s)
{ }
ostream& operator<<(ostream& out,Times& t)			// 输出时间
{
	//**********begin**********
	 out << t.hour << ":" << t.minute << ":" << t.second;
    return out;
	
	//**********end**********
}
Times operator+(int h,Times t)						// h小时之后的时间
{
	t.hour+=h;
	t.hour%=24;
	return t;
}
Times Times ::operator+(int s)					// s秒之后的时间
{
	int carry;                       // 进位
	Times t(*this);
	t.second+=s;
	carry=t.second/60;
	t.second%=60;
	t.minute+=carry;
	carry=t.minute/60;
	t.minute%=60;
	t.hour+=carry;
	t.hour%=24;
	return t;
}
Times Times::operator+(Times t)					// t时间之后的时间
{
	//**********begin**********
	int totalSeconds = hour * 3600 + minute * 60 + second;
    totalSeconds += t.hour * 3600 + t.minute * 60 + t.second;
    int newHour = totalSeconds / 3600 % 24;
    int newMinute = (totalSeconds % 3600) / 60;
    int newSecond = totalSeconds % 60;
    return Times(newHour, newMinute, newSecond);
	//**********end**********
}
```

```cpp
#include<iostream>
using namespace std;

class Times{
public:
	Times(int=0,int=0,int=0);
	friend ostream& operator<<(ostream&,Times&);	// 输出时间
	friend Times operator+(int h,Times);			// h小时之后的时间
	Times operator+(int s);							// s秒之后的时间
	Times operator+(Times t);						// t时间之后的时间
private:
	int hour;		// 时
	int minute;		// 分
	int second;		// 秒
};
//void writeToFile(const string);				        // 不用考虑此语句的作用

```

<mark>另一法</mark>

```cpp
#include"time.h"
//#pragma warning(disable:4996)

Times::Times(int h,int m,int s):hour(h),minute(m),second(s)
{ }
ostream& operator<<(ostream& out,Times& t)			// 输出时间
{
	//**********begin**********
	 out << t.hour << ":" << t.minute << ":" << t.second;
    return out;
	
	//**********end**********
}
Times operator+(int h,Times t)						// h小时之后的时间
{
	t.hour+=h;
	t.hour%=24;
	return t;
}
Times Times ::operator+(int s)					// s秒之后的时间
{
	int carry;                       // 进位
	Times t(*this);
	t.second+=s;
	carry=t.second/60;
	t.second%=60;
	t.minute+=carry;
	carry=t.minute/60;
	t.minute%=60;
	t.hour+=carry;
	t.hour%=24;
	return t;
}
Times Times::operator+(Times t)					// t时间之后的时间
{
	//**********begin**********

    Times temp;
    temp.hour=hour+t.hour;
    temp.minute=minute+t.minute;
    temp.second=second+t.second;

    if(temp.second>=60)
    {
        temp.minute++;
        temp.second-=60;
        if(temp.minute>=60)
        {
        temp.hour++;
        temp.minute-=60;
        if(temp.hour>=24)
        {
            temp.hour-=24;
        }
        }
    }
    return temp;
	//**********end**********
}
```

## 第4关：字符串中字符的循环移动
```cpp
#include <iostream>
#include <cstring>
using namespace std;

class STR {
private:
    char *s; // 数据成员，存放字符串
public:
    STR(char *p); // 构造函数，以形参初始化数据成员；
    void operator<<(int n); // 重载函数，使字符串左移n位；
    void print(); // 输出数据成员；
    ~STR(); // 析构函数，释放动态内存；
    friend void operator>>(STR &str, int n); // 使字符串右移n位；
};

// 构造函数的实现
STR::STR(char *p) {
    s = new char[strlen(p) + 1]; // 分配动态内存
    strcpy(s, p); // 拷贝字符串内容
}

// << 运算符重载的实现，用于左移字符串
void STR::operator<<(int n) {
    int length = strlen(s);
    n %= length;
    char *temp = new char[n + 1]; // 临时存储左移的部分字符
    for (int i = 0; i < n; ++i) {
        temp[i] = s[i];
    }
    temp[n] = '\0';
    for (int i = 0; i < length - n; ++i) {
        s[i] = s[i + n]; // 左移操作
    }
    for (int i = 0; i < n; ++i) {
        s[length - n + i] = temp[i]; // 将临时存储的部分字符放到末尾
    }
    delete[] temp; // 释放临时存储空间
}

// 输出字符串的实现
void STR::print() {
    cout << s << endl;
}

// 析构函数的实现，用于释放动态内存
STR::~STR() {
    delete[] s;
}

// >> 运算符重载的实现，用于右移字符串
void operator>>(STR &str, int n) {
    int length = strlen(str.s);
    n %= length;
    char *temp = new char[n + 1]; // 临时存储右移的部分字符
    for (int i = 0; i < n; ++i) {
        temp[i] = str.s[length - n + i];
    }
    temp[n] = '\0';
    for (int i = length - 1; i >= n; --i) {
        str.s[i] = str.s[i - n]; // 右移操作
    }
    for (int i = 0; i < n; ++i) {
        str.s[i] = temp[i]; // 将临时存储的部分字符放到开头
    }
    delete[] temp; // 释放临时存储空间
}
int main()
{
    char t[100];
    cin.getline(t,100);
	STR test(t);
    test.print();
	test<<4;
	test.print();
	test>>2;
	test.print();
	system("pause");
	return 0;
}
```