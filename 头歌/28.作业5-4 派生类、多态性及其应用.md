# 第一关  一维数组的升序和降序排列

## 答案  

```cpp
#include<iostream>
using namespace std;

class Array{                        // 数组类
public:
    Array(int*,int);                // 构造函数
    void Print();                   // 输出函数
    //******found******
    virtual void Fun()=0;              // 排序的纯虚函数
    ~Array();                       // 析构函数   
protected:
    int *arr;                       // 存储数组的动态空间
    int size;                       // 数组的大小
};

class Ascending:public Array{       // 升序类
public:
    Ascending(int *,int);           // 构造函数
    void Fun();                     // 升序排序
};

class Descending:public Array{      // 降序类
public:
    Descending(int *,int);          // 构造函数
    void Fun();                     // 降序排序
};

Array::Array(int *p,int n):size(n)
{
    int i;
    arr=new int[size];
    for(i=0;i<size;i++)
        arr[i]=p[i];
}

void Array::Print()
{
    int i;
    for(i=0;i<size;i++)
        cout<< arr[i] <<'\t';
    cout<<endl;
}

Array::~Array()
{
    delete []arr;
}

Ascending::Ascending(int *p,int n): Array(p,n)
{
}

void Ascending::Fun()
{
    int i,j,k,t;
    for(i=0;i<size-1;i++){
        k=i;
        for(j=i+1;j<size;j++)
            if(arr[j] < arr[k])k=j;
        if(k!=i)t=arr[k],arr[k]=arr[i],arr[i]=t;
    }
}

//******found******
Descending::Descending(int *p,int n): Array(p,n)
{
}

void Descending::Fun()
{
    int i,j,t;
    for(i=0;i<size-1;i++){
        for(j=i+1;j<size;j++)
            if(arr[j]>arr[i])
                t=arr[i],arr[i]=arr[j],arr[j]=t;
    }
}

int main()
{
    int t[7]={3,2,7,6,1,5,4};
    Array *p;
    Ascending test1(t,7);
    Descending test2(t,7);
    //******found******
    p=&test1; p->Fun(); p->Print();
    //******found******
    p=&test2 ; p->Fun(); p->Print();
    system("pause");
    return 0;
}
```

# 第二关 ：二维数组的输出和转置

## 答案

```cpp
#include<iostream>
using namespace std;

class ArrayShow{                    // 二维数组输出类
public:
    ArrayShow(int(*p)[5],int n);    // 用参数p初始化数据成员arr
    void show()const;               // 按要求输出二维数组
protected:
    int arr[5][5];                  // 二维数组
};

class ArrayTrans:public ArrayShow{  // 二维数组转置类
public:
    ArrayTrans(int(*p)[5],int n);   // 用参数p初始化数据成员arr
    void transpose();               // 转置
};

ArrayShow::ArrayShow(int(*p)[5],int n)
{
    int i,j;
    for(i=0;i<n;i++)
       for(j=0;j<5;j++)
           arr[i][j]=p[i][j];
}

void ArrayShow::show()const
{
    int i,j;
    for(i=0;i<5;i++){
       for(j=0;j<5;j++)
           cout<<arr[i][j]<<'\t';
       cout<<endl;
    }

}

ArrayTrans::ArrayTrans(int(*p)[5],int n):ArrayShow(p,n)
{
}

void ArrayTrans::transpose()
{
    int i,j,t;
    //********begin********
    for (i = 0; i < 5; i++) {
        for (j = i + 1; j < 5; j++) {
            t = arr[i][j];
            arr[i][j] = arr[j][i];
            arr[j][i] = t;
        }
    }
    //********end********
}

int main(void)
{
    int t[5][5]={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25};
    ArrayShow test1(t,5);
    ArrayTrans test2(t,5);
    cout<<"二维数组为："<<endl;
    test1.show();
    test2.transpose();
    cout<<"转置后为："<<endl;
    test2.show();
    system("pause");
    return 0;

}
```

# 第三关 字符串的复制和拼接

## 答案  

```cpp
#include<iostream>
#include<cstring>
using namespace std;

class String{                           // 抽象类
public:
    String(char* p);                    // 用参数初始化str
    virtual void operating(char*)=0;    // 功能函数
    char* getstring()const;             // 返回字符串
    int getlength(char*s)const;         // 返回字符串s的长度
    ~String();                          // 释放动态空间
protected:
    char *str;                          // 字符串
};

class StringCopy:public String{         // 字符串拷贝类
public:
    StringCopy(char* p);                // 构造函数
    void operating(char*);              // 拷贝函数
};

class StringCat:public String{          // 字符串拼接类
public:
    StringCat(char* p);                 // 构造函数
    void operating(char*);              // 拼接函数
};

String::String(char* p)
{
    str=new char[strlen(p)+1];
    strcpy(str,p);
}

char* String::getstring()const
{
    return str;
}

int String::getlength(char *s)const
{
    return strlen(s);
}

String::~String()
{
    delete []str;
}

StringCopy::StringCopy(char* p):String(p)
{

}

void StringCopy::operating(char*s)
{
    char* p;
    delete []str;
    str=new char[strlen(s)+1];
    p=str;
    while(*p++=*s++);
}

StringCat::StringCat(char* p):String(p)
{

}

void StringCat::operating(char*s)
{
    char *ss,*p1,*p2;
    //********begin********
    int len1 = strlen(str);
    int len2 = strlen(s);
    ss = new char[len1 + len2 + 1];
    p1 = str;
    p2 = ss;
    while (*p1) {
        *p2++ = *p1++;
    }
    p1 = s;
    while (*p1) {
        *p2++ = *p1++;
    }
    *p2 = '\0';
    delete[] str;
    str = ss;
  

  

    //********end********
}

int main(void)
{
    char *s1="abcde",*s2="ABCDEFGH",*s3="123456";
    StringCopy t1(s1);
    StringCat t2(s2);
    cout<<"s1:"<<s1<<endl;
    cout<<"s2:"<<s2<<endl;
    cout<<"s3:"<<s3<<endl;
    t1.operating(s2);
    cout<<"s1=s2:"<<t1.getstring()<<endl;
    t2.operating(s3);
    cout<<"s2+s3:"<<t2.getstring()<<endl;
    system("pause");
    return 0;
}
```