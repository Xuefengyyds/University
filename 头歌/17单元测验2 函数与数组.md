#### 链接
https://www.educoder.net/tasks/58935/1247006/j9rb7kufqonx?coursesId=58935


# 第1关：单项选择题

>1、设有变量定义和初始化语句如下：
    float x=2.5;
    char c(65);
    int y=x;              // ①
    int & r;                // ②
    int &rc=c;           // ③
    float &px=& x;     // ④
    char *pc=c;          // ⑤
则在注释部分标注编号的语句中，编译时没有语法错误的是（ A ）。
A、①
B、②
C、③
D、④
E、⑤
<mark>B:引用类型变量必须在定义时初始化  
C: c 不是一个整型变量，无法定义整型的引用变量指向它  
D: px 是一个浮点类型的引用变量，但是 &x 是一个指向浮点类型变量 x 的指针  
E:c 是一个字符变量，不能直接赋值给字符指针,正确的为char *pc=&c

>2、
设有函数说明如下：  
    int *f(int *p,int n);  
则该函数的函数体中返回语句应是（ C ）。  
A、return *p;  
B、return & p;  
C、return p;  
D、return;  
<mark>
A.return * p 表示指针所指的值
返回类型为 int *，所以应返回指向整型的指针，而不是整型值或指针的引用</mark>  


>3、  
下列一维数组的定义中正确的是（ C ）。  
A、  
int n=10;  
int a[n];  
B、  
const float n=10;  
float b[n];  
C、char c[127/2];  
D、double d[ ];  
<mark>A、int n=10;  
int a[n];  
这个错误在于n不是一个常量表达式，因此它不能作为数组的大小。  
B、const float n=10;  
float b[n];  
尽管n是const类型，但在C++中，const变量在编译时被视为常量，但由于n为浮点型常量  
D、double d[ ];  
错误在于数组的维度不能留空，必须指定一个大小。  


>4、  
下列二维数组声明和初始化中错误的是（ D ）。  
A、  
int a[][3]={1,2,3,4,5,6,7,8,9};      
B、  
int a[][3]={{1,2},{3,4},{5,6}};  
C、  
int a[3][3]={{1},{2,3},4,5};  
D、  
int a[3][]={{1,2},{3,4},{5,6}};  
<mark>在二维数组中，只有第一维度可以省略，第二维度必须指定。</mark>  


>5、  
下列字符数组声明和初始化中正确的是（ B ）。  
A、  
char sl[3]={"a","b","c"};  
B、  
char s2[3]={'a',98,99};  
C、  
char s3[]={'C++'};  
D、  
char s4[3]={"C++"};  
<mark>A、char sl[3]={"a","b","c"};  
这是错误的，因为用双引号括起来的是字符串，而不是单个字符，所以不能用来初始化字符数组。  
C、char s3[]={'C++'};  
正确为char s3[]={"C++"}    
D、char s4[3]={"C++"};  
因为字符串"C++"包括了四个字符，而数组s4只能容纳三个字符，因此这个初始化会导致溢出。  


>6、  下列关于数组和指针的操作中正确的是（ B ）。  
A、int a[5],*pa=& a;  
B、float b[5],*pb=&b[1];  
C、double c[3][5],*pc=c;  
D、char d[3][5],(*pd)[3]=d;  
E、int* e[5],*pe=e;  
F、int f[3][5],*pf[5]=f;  
<mark>A、int a[5],*pa=& a;  
这里应该是 *pa = &a[0];，取数组的地址后赋值给指针。数组a本身就是一个地址  
C、double c[3][5],*pc=c;  
因为 c 是一个二维数组，所以需要使用二维数组的指针double c[3][5],(*pc)[5]= c;
D、char d[3][5],(*pd)[3]=d;  
这里应该是 (*pd)[5]=d;，  
E、int* e[5],pe=e;  
这里应该是 int e[5],*pe=&(e[0]);，要取数组的地址赋值给指针。  
F、int f[3][5],*pf[5]=f;  
这里应该是 int (*pf)[5]=f;，pf 是一个指针，指向包含5个整数的数组。  


>7、  
设有程序段如下：  
    int x=3,*p=& x;  
    int &r=x,y=x;  
    r=5,y=10;  
则下列表达式中值为15的是（ D ）。  
A、x*r  
B、x+5  
C、x+12  
D、x+y  
E、p+y  
F、p+12  
<mark>x=5,*p=5.,r=5,y=10;  

>8、  
设有函数声明和变量定义如下：  
    void f(int *x,int &y);  
    int m=5,n=10;  
则下列函数调用表达式正确的是（ A ）。  
A、f(&m,n)
B、f(&m,&n)
C、f(*m,&n)
D、f(*m,n)
<mark>在这个表达式中，&m 给出了 m 变量的地址，而 n 作为一个整数传递给函数。  

>9、    
设有函数和变量定义如下：  
    char f(int x){ return x;} // ‘A’的ASCII值为65  
    double n(65.5);   
则函数调用表达式“f(n)”的值是（ D ）。  
A、65.5  
B、65.0  
C、65  
D、‘A’  
<mark>double->int,f(n)即为f(65)返回字符型

## 内联函数  
*内联函数是一种C++编程语言中的特殊函数，使用 `inline` 关键字来声明。编译器会尝试在调用内联函数的地方，直接将函数的代码插入到调用点，而不是通过普通的函数调用来执行。内联函数通常用于简单的函数，可以提高程序的执行效率，因为它避免了函数调用的开销。*

### 二.为什么使用内联函数
内联函数最初的目的：代替部分 #define 宏定义；
使用内联函数替代普通函数的目的：提高程序的运行效率；  

为了消除函数调用的时空开销，C++ 提供一种提高效率的方法，即在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。这种在函数调用处直接嵌入函数体的函数称为内联函数（Inline Function）。但也存在缺点，就是每一调用处均会展开，增加了重复的代码量。
>可以理解为内联函数的关键词是：替换

- 函数前面加上inline一定会有效果吗？  
答：不会，使用内联inline关键字修饰函数只是一种提示，编译器不一定认。  

- 如果不加inline就不是内联函数了吗？  
答：存在隐式内联，不用inline关键字，C++中在类内定义的所有函数都自动称为内联函数。  

- 内联函数一定就会展开吗？
答：其实和第一个问题类似，还是看编译器认不认。  

- 在什么情况下内联函数会展开？  
答：首先需要满足有inline修饰或者是类中的定义的函数，然后再由编译器决定。  

1.隐式内联：如第三节说的C++中在类内定义的所有函数都自动称为内联函数，类的成员函数的定义直接写在类的声明中时，不需要inline关键字

2.显示内联：需要使用inline关键字

>在使用内联函数时要留神：
1.在内联函数内不允许使用循环语句和开关语句；
2.内联函数的定义必须出现在内联函数第一次调用之前；
3.类结构中所在的类说明内部定义的函数是内联函数。

**内联函数链接**  
https://blog.csdn.net/wzz953200463/article/details/116303725

>10、
关于内联函数，下列说法错误的是（ B ）。
A、说明内联函数的关键字是inline
B、用inline说明的函数都是内联函数
C、内联函数是用内存空间换取执行时间的函数
D、内联函数具有更高的执行效率
<mark> B说法错误的是，用inline说明的函数并不一定都是内联函数，这取决于编译器是否选择将其作为内联函数来处理。  
C、内联函数是用内存空间换取执行时间的函数。  
内联函数是为了节省调用函数的开销，它通过在调用点将函数的代码插入到程序中，从而减少了函数调用的开销.  

```cpp
//11、  
设有程序如下：  
 
    #include
    using namespace std;
    void f(float x=5,float y);           // ①
    int main( )
    {
        void f(float,float=30);          // ②
        float a=10;
        f(float a,20);                   // ③
        void f(a,20);                    // ④
        cout<<f(a,20)<<endl;             // ⑤
        return 0;
    }
    void f(float x,y)                            // ⑥
    {
        cout<<x+y<<endl;
    }

则在注释部分标有编号的行中，没有语法错误的是（ B ）。  
A、①  
B、②  
C、③  
D、④  
E、⑤  
F、⑥  
```
>A、① 中的函数声明有默认值的应该放在后面  
C、③ 中的函数调用语法错误，实参传入不需要参数类型  
D、④ 中的函数调用语法错误，不需要前面加void  
E、⑤ 中的 cout 语句中的函数调用语法错误,无返回值  
F、⑥ 中的函数定义中缺少了形参的参数类型，也存在语法错误。  
函数声明 void f(float, float=30);它使用了默认参数。在 C++ 中，函数参数可以有默认值，这使得在调用函数时可以省略某些参数。


>12、  
下列不能作为函数重载判断依据的是（ A ）。  
A、函数类型不同  
B、函数名相同  
C、参数个数不同  
D、参数类型不同  
<mark>函数类型不同不能作为函数重载的判断依据。在函数重载中，只有函数名和参数列表可以作为判断依据，而函数类型不同并不影响函数的重载。  
重载依据： 1. 形参类型； 2. 参数个数； 3. 形参的顺序； 4. const,有const 只读，无const可读写  
A:函数类型不同，返回值类型不同，但返回值可能会发生强制转化，且如果不需要返回值呢？那么编译就不能判断需要哪个函数


>13、关于变量的作用域，下列说法错误的是（ D ）。  
A、在不同函数中可以定义名称相同的变量  
B、函数的形参是局部变量，只能在该函数的函数体中使用  
C、在函数体中定义的变量，只能在该函数的函数体中使用  
D、全局变量与局部变量同名时，默认使用的是全部变量  
<mark>当全局变量和局部变量同名时，默认使用的是局部变量，它会覆盖全局变量的值</mark>

## 变量的存储类型

使用auto 关键字声明自动变量，使用static关键字声明静态变量。

在函数中定义**局部变量时，如果没有被声明为其他类型的变量都是自动变量。**

**全局变量默认为是静态变量**

在编写代码时，有时需要在调用函数中的某个局部变量以后，这个变量的值不消失，并且保持原值不变，也就是该函数所占用的存储空间不被释放，在下次调用该函数时，变量中的值是上次调用该函数结束时变量的值。这时，使用的变量类型是静态变量，使用static 关键字进行声明。  
  

**静态变量与自动变量的区别主要表现在：**

- Ⅰ ）静态存储类型的局部变量是在静态存储区内分配内存单元，在程序的整个运行期间内都不释放空间。而自动类型的局部变量属于动态存储类型，是在动态存储区内分配存储单元的，函数调用结束后存储单元即被释放。

- Ⅱ）静态局部变量是在编译时赋初始值，并且只赋一次初值，在以后每次调用函数时，只是使用上一次函数被调用结束时变量的值。而自动局部变量的初值不是在编译时赋予的，而是在函数调用时赋予的，每调用一次函数都会对变量重新赋一次初值。

- Ⅲ）<mark>如果调用的静态局部变量没有对其进行赋值，则该变量的默认值为0后者为空字符串。而对于自动局部变量来说，如果不赋值，则变量的值是一个不确定的值，</mark>这是因为在函数被调用时，会为该变量分配一个存储空间，在函数结束时，存储空间被释放，这两次分配的存储空间是不一样的，存储空间中的值也是不确定的。

>14、关于变量的存储类型，下列说法错误的是（ C ）。  
A、函数形参默认为是自动变量  
B、全局变量默认为是静态变量  
C、局部变量没有缺省值  
D、静态变量具有缺省值0  
<mark>局部变量在没有明确赋值时会有一个缺省值，这个值是随机的。


>15、  
设有数组声明和初始化语句如下：  
    int a[10]={1,2,3,4,5};  
    char s[10]=”abced”;  
则下列的输入/输出语句中存在语法错误的是（ A ）。  
A、cin>>a;  
B、cout<< a;  
C、cin>>s;  
D、cout<< s;  
<mark>A:a是整形数组不能直接输入， B：输出的是a数组的首位地址


>16、  
设有字符数组声明和初始化语句如下：  
    char str[]={“123456789”},*s1=str,*s2=s1++;  
则下列说法中正确的是（ D ）。  
A、str[0]与s1[0]的值都是字符‘1’  
B、s1[1]与s2[1] 的值都是字符‘2’  
C、语句“cout<< s1;”将输出字符串“123456789”  
D、语句“cout<<*s2;”将输出字符‘1’  
E、语句“cout<<*s2;”将输出字符串“123456789” 
<mark> s1指针多移动了一个字节，s2指向的是str的首地址 

>17、  
设有函数和数组的声明语句如下：  
    void f1(int p[],int n);  
    void f2(int *p,int n);  
    int a[10],len=10;  
则下列函数调用语句中错误的是（ A ）。  
A、f1(a[10],len) ;  
B、f1(a,len);  
C、f2(&a[0],len);  
D、f2(a,len);  
<mark>数组名可以被解释为指向数组第一个元素地址的指针  
传递整个数组作为参数，应该直接使用数组名  
A:正确为 f1(&a[10],len);  
这两种函数是一个意思的</mark>

>18、   
设有函数和数组的声明语句如下：  
    void f(char p1[],char *p2);  
    char s[20],str[30];  
则下列函数调用语句中正确的是（ C ）。  
A、f(s[],*str) ;  
B、f(s[20],str[30]);  
C、f(s,str);  
D、f(s,&str);  
<mark>A、f(&s[0],str) ;  
B、f(&s[20],&str[30]);  
D、f(s,str);  

### 二维数组与指针

>19、  
设有函数和数组的声明语句如下：  
    void f1(int p[],int n);  
    void f2(int (*p)[5],int n);  
    int b[3][5];  
则下列函数调用语句中错误的是（ D ）。  
A、f1(b[0],15) ;  
B、f1(*b,15);  
C、f2(&b[0],3);  
D、f2(&b[0][0],3); 
<mark>f1是用元素指针传递二维数组,f2是用行指针传递二维数组  
调用f1有三种方式，其实参是二维数组第一行第一列元素的地址，f1(b[0],15) ,f1(*b,15),f1(&b[0][0]);
调用f2有两种方式，其传递的都是二维数组首行的地址，f2(b,3)，或者f2(&b[0],3);  ***二维数组名即为行地址***
b[0]和 * b都是指向数组b的第一行第一个元素地址的指针（元素地址）。</mark>

|    分类      |   表示方法     | 备注          |
| :----------: | :-----------: | :-----------:|
|行指针        |   p2+i,&p2[i]  | 下标为i行的地址  
| 元素指针     |*(p2+i)+j ,p2[i]+j | 下标为i行j列的元素地址  
元素 |    *(*(p2+i)+j) , * (p2[i]+ j),p2[i][j]|下标为i行j列的元素

定义行指针 `数据类型 (*指针变量名)[二维数组列数]` eg:`float (*p2)[5]`  



>20、  
设有声明语句如下：  
    char str[]="12345\0abcde",*s=str;  
则下列说法中错误的是（ A ）。  
A、sizeof(s)的值为12   
B、strlen (str)的值为5  
C、strlen(s)的值为5  
D、strcmp(s,"12345")的值为0  
<mark> sizeof(str)=12;  
A：输出的是字符型指针的大小  
B.s是指向str的字符型指针，遇到'\0'停止，输出实际长度  
C:strlen 函数会计算字符串的长度，直到遇到字符串结束标志为止
D：返回的是1 </mark>  

## 填空题  
```cpp
运行下列程序，第1行输出是D，第2行输出是e，第3行输出是f。
    #include
    using namespace std;
    void f(char x,char &y,char *z)
    {
       x+=32 ;
       y+=32 ;
       *z+=32 ;
    }
    int main()
    {
       char a=’D’,b=’E’,c=’F’;
       f(a,b,&c);                //a的实参未改变
       cout<<a <<’\n’<<b<<’\n’<<c<<endl;
       return 0;
    }
```

```cpp
运行下列程序，第1行输出是24，第2行输出是213，第3行输出是111。
    #include< iostream >
    using namespace std;
    int a, b(1);
    int main( )
    {
       int a=2;
       {
              int a=3;
              a+=10;            //a为局内变量a=13
              b+=10;            //b为全局变量b=11
              cout<<a+b<<endl;  //24      
       }
       a+=100;                    //局部变量a=102
       b+=100;                    //b=111
       cout<<a+b<<endl;           //213 
       cout<<::a+::b<<endl;       //两个全局变量 0+111=111
       return 0;
    }
```

```cpp
运行下列程序，第1行输出是30，第2行输出是40。
    #include< iostream >
    using namespace std;
    int fun(int n)
    {
       static int a=5;            //定义静态变量，函数体调用后不清除
       int b=5;                   // 
       a+=n;
       b+=n;
       return (a+b);              //返回a+b
    }
    int main( )
    {
       cout << fun(10) << endl;    //b=15，a=15
       cout << fun(10) << endl;    //b=25，a=15
       return 0;
    }
```

```cpp
运行下列程序，第1行输出是1，第2行输出是2，第3行输出是1024。
    #include
    using namespace std;
    int f(int x,int n)
    { 
        if(n==0)return 1;
        else if(n==1)return x;
        else return f(x,n/2)*f(x,n-n/2);    //递归传递 输出x^n 
    }
    int main(void)
    {
        cout<<f(2,0)<<endl;    //return 1
        cout<<f(2,1)<<endl;    //return 2
        cout<<f(2,10)<<endl;   //return  f(x,n/2)*f(x,n-n/2);  
        return 0;
    }
```

**如何进行进制转化的函数**

```cpp

运行下列程序，第1行输出是1，第2行输出是100，第3行输出是177。
    #include
    using namespace std;
    void fun(int n,int b)
    {
        if(n>=b) fun(n/b,b);
        cout<<n%b;
    }
    int main(void)
    {
        fun(1,2);            //输出1
        cout<<endl;          
        fun(4,2);            //输出100
        cout<<endl;
        fun(127,8);          // 
        cout<<endl;
        return 0; 
    }
//将一个整数转换为另一个进制表示的形式（以b为基数）。当n和b分别表示十进制数和目标进制时，这个函数可能会打印出n的b进制表示。
```

```cpp
运行下列程序，第1行输出是 4，第2行输出是 5.5 ，第3行输出是 9 。
    #include
    using namespace std;
    void fun(float x=1.5,float y=2.5)
    {
        cout<<x+y<<endl;
    }
    int main(void)
    {
        fun();        //4
        fun(3);        //5.5
        fun(4,5);      //9
        return 0;
    }
```

**下列程序分别通过递推法和递归法求n!**

```cpp
    下列程序分别通过递推法和递归法求n!，请完善程序。
    #include
    using namespace std;
    int f1(int n)        // 递推法：n!=1*2*…*(n-1)*n
    {
        int t=1,i=2;
        while(i<=n){ 
            t=t*i; 
            i++;
        }
        return t;
    }
    int f2(int n)    // 递归法：n!=n* (n-1)!
    {
        if(n==0||n==1)return 1;
        else return n* f2(n-1); 
    }
    int main(void)
    {
        int n;
        cin>>n;
        cout<<n<<"!="<<f1(n)<<endl;
        cout<<n<<"!="<<f2(n)<<endl;
        return 0;
    }
```

```cpp

设有声明语句如下：
    double a[10]={1,2,3,4,5,6,7,8},*p=&a[2]; 
    double b[][4]={9,10,11,12,13,14,15,16,17,18}; 
则a[0]的值为1，a[8]的值为0，p[0]的值为3，p[2]的值为5，*(p+4)的值为7，b[1][1]的值为14，b[2][2]的值为0。
```

```cpp
有程序段如下：
    char s1[100]="student",s2[100]="teacher",s3[100]="student\0teacher";
    strcpy(s1,s2);
    strcat(s2,s3);
则执行上述程序段后，s1中的字符串为teacher，s2中的字符串为teacherstudent。
```

```cpp
10、
运行下列程序，第1行输出是123，第2行输出是456，第3行输出是789。
    #include
    using namespace std;
    void print(int p[][3],int n)
    {
        int i,j;
        for(i=0;i<n;i++){
            for(j=0;j<3;j++)
                cout<<* (* (p+i)+j);
            cout<<endl;
        }
    }
    int main(void)
    {
        int b[3][3]={1,2,3,4,5,6,7,8,9};
        print(b,3);
        return 0;
    }
```

**设计一个程序，将字符数组中的字符按ASCII值的大小逆序排列，即重新排列后相邻的2个字符，前面的字符不小于后面的字符。**

<mark>方法1</mark>

```cpp
#include<iostream>
#include<cstring>
using namespace std;

void Sort(char arr[]) {
    int n = strlen(arr);
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] < arr[j + 1]) { 
                swap(arr[j], arr[j + 1]);
            }
        }
    }
}

int main(void) {
    char arr[100];
    cin.getline(arr,100);
    cout<<"排序前的字符串："<< arr<< endl;
    Sort(arr);
    cout <<"排序后的字符串：" << arr << endl;
    system("pause");
    return 0;
}
```

<mark>方法2</mark>

```cpp
#include<iostream>
using namespace std;
void sort(char *s)
{
    char *p1=s,*p2,t;
    while(*(p1+1)){
        for(p2=p1+1;*p2;p2++)
            if(*p1<*p2){
                t=*p1;
                *p1=*p2;
                *p2=t;
            }
        p1++;
    }
}
int main(void)
{
    char str[100];
    cin.getline(str,100);
    cout<<"排序前的字符串："<<str<<endl;
    sort(str);
    cout<<"排序后的字符串："<<str<<endl;
    system("pause");
    return 0;
} 
```