## 选择
>1、设有说明语句“int b[10],*p1=b,*p2=p1++;”，则下列说法正确的是(**B**)。  
A、p1[i]与b[i]表示同一个元素  
B、p2[i]与b[i]表示同一个元素  
C、p1[i]与p2[i]表示同一个元素  
D、“p1=b++;”后，p1[i+1]与b[i]表示同一个元素  
<mark> p1后置++，指向的地址多加4个字节

>2、设有下列说明语句：
int a[]={1,2,3,4,5},*pa=a;
char s[]={“1,2,3,4,5”},*ps=s;
则下列能输出数组所有元素的语句是（**B**）。
A、cout<<pa; 
B、cout<<ps;
C、cout<<*pa; 
D、cout<<*ps;
<mark>  
选项 A 中的语句 cout<<pa; 将输出指针 pa 的地址，而不是数组 a 的所有元素  
选项 C 中的语句 cout<< *pa; 将输出整数数组的第一个元素，而不是整个数组的所有元素  
选项 D 中的语句 cout<< *ps; 将输出字符串数组的第一个字符1，而不是整个字符串数组</mark>  

>3、下列存在语法错误的语句是（ D ）。  
A、char a[20]={"Programming"};  
B、char a[20],*p=a;p="Programming";  
C、char *a; a="Programming";   
D、char a[20]; a="Programming";  
<mark>  
A也可以表达为char a[20]="Programming";  
选项 C 中，语句 char *a; a="Programming"; 是合法的，它将一个字符串常量赋值给了字符指针a  
D、char a[20]; a="Programming";。在这个语句中，数组a是一个字符数组，而"a"是一个字符串常量，不能直接赋值给字符数组a</mark>  

>4、下列数组和指针的使用中正确的是（ A ）。  
A、int a[5];int *pa=a;  
B、int b[5],*pb;*pb=b;  
C、double c[5] ,*pc=*c;  
D、char d[5] ,*pd=& d;   
<mark>B: 这两行代码中，首先定义了一个包含5个整数的数组b。然后定义了一个整型指针pb，但没有将其指向任何地方。接下来，尝试将数组b的值赋给未初始化的指针pb，这是错误的。
正确的写法应该是 int b[5], *pb; pb = b;，将指针pb指向数组b的首地址。  
C:这行代码首先定义了一个包含5个字符的数组d。然后定义了一个字符指针pd，将其指向数组d的首地址。  
D:这行代码尝试将数组 d 的地址赋给指针 pd，然而在 C++ 中，数组的名字代表数组的首地址，因此应该直接使用 char d[5], *pd = d;，将指针 pd 指向数组 d 的首地址。</mark>


>5、
下列关于数组和指针的操作中正确的是（ D ）。  
A、double c[3][5],*pc=c;  
B、char d[3][5],(*pd)[3]=d;  
C、int* e[5],*pe=e;  
D、int f[3][5],(*pf)[5]=f;  
<mark>二维数组名代表数组首行地址  
C 中，存在一个错误：int * e[5], *pe = e;  
这行代码首先定义了一个指针数组e，每个元素都是一个整型指针。然后尝试将指针数组 e 的地址赋给指针 pe，这是错误的写法。  
正确的写法是 int* e[5], **pe = e;，将指针 pe 定义为一个指向整型指针数组的指针，而不是直接将指针数组 e 的地址赋给指针 pe。  

>6、设有字符数组声明和初始化语句如下：  
    char str[]={“123456789”},*s1=str,*s2=s1++;
则下列说法中正确的是（ D ）。  
A、str[0]与s1[0]的值都是字符‘1’  
B、s1[1]与s2[1] 的值都是字符‘2’  
C、语句“cout<<s1;”将输出字符串“123456789”  
D、语句“cout<<*s2;”将输出字符‘1’  

>7、设有声明语句如下：
    char str[]="12345\0abcde",*s=str;  
则下列说法中错误的是（ B ）。  
A、sizeof(str)的值为12  
B、sizeof(s)的值为12  
C、strlen(s)的值为5  
D、strcmp(s,"12345")的值为0  
<mark>错误的说法是 B、sizeof(s)的值为12。
指针 s 的大小是固定的，通常为机器字长，与所指向的对象无关。因此，sizeof(s) 的值通常为 4 或 8，具体取决于系统。  
其他说法是正确的：  
A、sizeof(str) 的值为 12，因为字符串 "12345\0abcde" 一共包含 12 个字符（包括末尾的空字符）。  
C、strlen(s) 的值为 5，因为字符串 "12345" 的长度为 5。  
D、strcmp(s, "12345") 的值为 0，因为 s 指向的字符串与 "12345" 相等。</mark>


>8、若有定义：char *s=“programming” ；  
以下叙述错误的是( D)。  
A、变量s中存放了字符串的地址  
B、s[0]中存放了字符p  
C、*s中存放了字符p  
D、s中存放了一个字符串  
<mark>  
D:变量 s 存放的是字符串 "programming" 的地址，而不是整个字符串本身。</mark>  

>9、有一个字符串指针说明char *s1；其含义是(D)。  
A、分配指针空间及字符串空间  
B、不分配指针空间及串空间  
C、分配串空间不分配指针空间  
D、不分配串空间分配指针空间   
<mark>char *s1; 这个语句声明了一个字符型指针 s1，它分配了指针空间但不分配具体的字符串空间。这意味着 s1 只是一个指针，它可以指向某个字符串的首地址，但它本身并没有存储任何具体的字符串数据。</mark>

>10、  
若有说明语句：int s[4][6], t[6][4],(*p)[6];  
则以下选项中，正确的是 (B )  
A、p=t;  
B、p=s;  
C、p=s[0];  
D、p=t[0];  

# 用指针操作数组
## 指针操作一维数组  
### 用指针变量操作一维数组有下列两种基本方法。
- 1、以指针变量名代替数组名，实现数组的操作。  
一维数组的数组名（a）是第一个元素的地址，当指针变量（p）指向一维数组首元素时，该指针变量的值与数组名的值相等，p[i]也与a[i]相同。  
>（1）a是数组首地址；如上一关所述，a+i是数组中下标为i的元素的地址；下标为i的元素的值为*(a+i)，即a[i]；对元素（变量）的地址进行取值运算是元素的值。  
（2）当p指向数组的首元素时，p+i也是数组中下标为i的元素的地址；对该地址进行取值运算（*(p+i)），也是下标为i的元素的值，即p[i]或a[i]。  
（3）p和a虽然都是地址，且值相等；但p是变量，可以移动；而a是常量，不能移动。  
（4）只有当p指向a的首元素时，p[i]才a[i]相同；若p不指向a的首元素，则p[i]不等于a[i]。  

- 2.指针变量指向数组中的各个元素，通过指针的间接引用得到元素的值，如下所示。  
```cpp
int i;
float b[5]={1,2,3,4,5},*p=b;
for(i=0;i<5;i++){
    cout<<*p;
    p++;
}
```
>（1）第1次循环，p指向b[0]，*p为b[0],将其输出后，p指向下个元素，即b[1]；第2次循环，*p为b[1]，将其输出后，p再指向下个元素；以此类推，只到输出所有元素，循环结束。  
（2）以上程序段，每次循环输出当前元素后，指针指向下个元素，指针在不停向后移动；如果没有p++;，则指针将不移动，程序将把首元素输出5遍。  
（3）以上程序段运行后，p[i]将不再等于b[i]，为什么？  

## 指针操作二维数组
用行指针和元素指针都能操作二维数组，如下所示。  
- 1.以行指针变量名代替二维数组名，实现数组的操作。
当行指针变量（p）指向二维数组（b）首行时，p[i][j]与b[i][j]相同。  

- 2.以行指针取元素的值，实现二维数组的操作。  
如第一关所述，当行指针变量（p）指向二维数组（b）首行时，p+i是二维数组下标为i行的行指针，对该行指针进行取值运算可得到下标为i行的第一个元素的地址，即*(p+i)是i行的第一个元素的地址；该地址是元素地址，该地址加j将在元素间移动，即*(p+i)+j是下标为i列标为j的元素的地址，即&b[i][j]是下标为i列标为j的元素的地址；对元素地址再进行取值运算，可得到元素的值，即*(*(p+i)+j)是元素b[i][j]。其中*(p+i)等同于p[i],所以*(*(p+i)+j)也可以写成*(p[i]+j)。
用行指针使用二维数组元素要经过以下2步操作。  
>（1）对行指针（地址）进行取值运算，得到元素地址。  
（2）对元素地址再进行取值运算，得到元素。  

在这个过程中，要注意行和列的位置。在行指针变量（p）指向二维数组（b）首行时，p为b首行的行地址，*p为首行第1个元素的地址，**p为首行的第1个元素。  

- 3、通过元素指针使用二维的方法与元素指针使用一维的方法相似。由于二维数组在计算机内存中是按先行后列的顺序连续存放的，故可以将该连续内存空间看成是一个一维数组；只要定义一个元素指针，并指向二维数组中的第1个元素，通过指针的间接引用就可以得到元素的值，如下所示。  
```cpp
int i;
float b[3][5]={1,2,3,4,5},*p=&b[0][0];
for(i=0;i<3*5;i++){
    cout<<p[i];
}
或者

int i;
float b[3][5]={1,2,3,4,5},*p=&b[0][0];
for(i=0;i<3*5;i++){
    cout<<*p;
    p++;
}
```
>以上两个程序段都可以实现二维数组的输出，再次提醒2点。
（1）以上的指针p是元素指针，必须也只能指向二维数组的和一个元素b[0][0]。  
（2）此时，二维数组已当作一维数组，一维数组元素的个数为二维数组的行数乘列数。  

## 第2关：一维数组中的元素升序排序

### 排序算法
一维数组的排序有多种方法，其中选择排序法有直接选择排序和间接选择排序之分，直接选择排序法是在排序的过程中一旦发现不满足要求的元素就交换，间接选择排序法在一趟排序时最多交换一次，间接选择排序比较直接选择排序效率更高，即运算量更小。  
对于具有n个元素的一维数组，选择排序的算法思想进行n-1趟排序，每趟排序确定一个元素的位置，n-1趟排序后确定了n-1个元素的位置，最后剩下来的一个元素自动落入最后的位置。以数组a为例进行升序，具体的排序方法如下所示。  
>1、直接选择排序法
（1）第1趟（i=0），把最小元素放入[0]位置，即确定元素a[0]。  
（2）第2趟（i=1），把次小元素放入[1]位置，即确定元素a[1]。  
（3）以此类推，第n-1趟（i=n-2），把次大元素放入[n-2]位置，即确定元素a[n-2]；最大元素自动落入[n-1]位置。
这可以通过以下循环实现。  
```cpp
for(i=0;i<n-1;i++){    // 进行n-1趟排序，外循环
    ...;
}
```
即每次循环确定当前位置[i]的元素a[i]。那么当前位置的元素是怎样确定的呢？即循环体是什么？  
确定当前位置元素a[i]的方法是，把当前元素a[i]和其后的所有元素a[j]比较，如果不满足排序要求，即当前元素a[i]比其后的元素a[j]大，则交换a[i]和a[j]。这也是通过循环来实现的，如下所示。  
```cpp
for(j=i+1;j<n;j++){    // 把当前元素a[i]和其后的所有元素a[j]进行比较，内循环
    如果a[i]>a[j]，则交换a[i]和a[j];
}
```
>2、间接选择排序法  
间接选择排序法也进行n-1趟排序，与直接选择排序法不同的每趟排序时先确定当前最小元素的位置，然后把当前最小元素交换到当前位置，具体如下所示。  
```cpp
k=i;    // k为当前最小元素所在的位置，假设当前最小元素在i位置
for(j=i+1;j<n;j++){    // 把当前最小元素a[k]和其后的所有元素a[j]进行比较
    如果发现更小的元素（a[k]>a[j]），则记录该位置（k=j）;
}
```
如果当前最小元素不在当前位置（k!=i），则交换a[i]和a[k]；  
直接选择排序和间接选择排序的外循环是相同的。  

<mark>程序</mark>

```cpp
#include <iostream>
using namespace std;

int main()
{
	int a[10],i,j,k;
	int *p;
	//**********found**********
	p=a; //指针变量指向一维数组
    for(i=0;i<10;i++)    	
		cin>>p[i];   
	for(i=0;i<9;i++)
	{
		k=i;
		//**********found**********
		for(j=i+1;j<10;j++)
 		    if (*(p+j)<*(p+k))
                k=j;
		int  t=*(p+k);
		//**********found**********
		*(p+k)=*(p+i);
         *(p+i)=t;
	}
    cout<<"the sorted array :\n";
    for(i=0;i<10;i++){
        cout<<*p<<"    ";
        //**********found**********
		*p++;
    }
    cout<<endl;
	system("pause");
	return 0;
}
```

## 字符型指针与字符数组和字符串  
- 1、用字符型指针表示字符数组  
（1）当字符型指针变量指向字符数组时，可用该指针变量表示其所指向的字符数组，如下所示。
```cpp
char str[100],*s1,*s2;
s1=str;
cin.getline(s1,100);
cout<<s1<<endl;
s2=&str[5];
cout<<s2<<endl;
```
>上述程序第2行，字符型指针变量s1指向字符数组str的首元素，所以指针变量s1表示字符数组str，第3行把键盘输入的内容存入数组str；若键盘输入内容为abcdefgh 12345，则数组str中就保存了字符串abcdefgh 12345，同理第4行输出字符串abcdefgh 12345。  
第5行，字符型指针变量s2指向字符数组str的第6个元素，所以指针变量s2就表示字符数组str中第6个元素开始的字符数组；若把s2也看成一个字符数组，s2中的第1个元素是数组str中第6个元素；所以第6行输出字符串fgh 12345。  
预期输入：abcdefgh 12345  
预期输出：  
abcdefgh 12345  
fgh 12345  

（2）指针变量虽然可以表示字符数组，但两之间是有区别的。指针变量中保存的是一个地址，字符数组保存的是一串字符。例如上述程序中，  
字符数组str中保存的内容：abcdefgh 12345  
指针变量s1中保存的内容：001AFED8（地址）  

- 2、用字符型指针表示字符串  
用字符型指针表示字符串主要有下列2种方法。  
（1）定义字符型指针变量时用字符串对其初始化，如下列程序段中的p1所示。  
（2）先定义一个字符型的指针变量，然后用字符串对其赋值，如下列程序段中的p2所示。  
```cpp
char *p1="abcde",*p2;
p2="12345678";
cout<<p1<<endl;
cout<<p2<<endl;
```
>此时，指针变量p1就表示字符串"abcde"，指针变量p2就表示字符串"12345678"。  
预期输出：  
abcde  
12345678  

注意上面2个程序段的区别。指针变量s1表示的是字符数组，其指向的内容可变；而指针变量p1表示的是字符串常量，其指向的内容不可变，如下的操作都是语法错误。  
```cpp
strcpy(p1,"123");    // 语法错误，p1指向的内容是字符串常量
p2[0]='a';            // 语法错误，p2中的所有字符都是字符常量
```

## 用字符型指针操作字符数组  
用字符型指针操作字符数组的基本方法也是遍历，即首先使指针指向字符数组的第1个元素；然后通过循环操作字符数组，只要指针所指的字符不是字符串结束标记，指针就向后移；在循环的过程中完成相应的操作。如下列程序段求字符数组保存的字符串的长度。  
```cpp
int len=0;
char str[100],*s;
s=str;
cin.getline(s,100);
while(*s){
    len++;
    s++;
}
```
>上例中，循环条件*s等同于*s!='\0'，是以指针s所指的字符为判断条件，不能写成s；如果写成s，是以地址为判断条件，即只要指针不悬空就继续循环。

## 求一串字符中单词的个数
```cpp
#include <iostream>
using namespace std;

int main()
{
    int words=0;    // 单词数量
	char text[100],*s;
    cout<<"请输入一个字符串：\n";
    //**********found**********
    cin.getline(text,100);	//用键盘输入一串字符
	s=text;
    while(*s)
    {
        if(*s!=' '&&(*(s+1)==' '||*(s+1)=='\0'))words++;
        //**********found**********
        *s++;
    }
    //**********found**********
    cout<<text<<" 中有 "<<words<<" 个单词。\n";
	system("pause");
	return 0;
}
```
>测试输入：I am a boy.
预期输出：
I am a boy.中有4个单词